{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-deprecations #-}
{-# OPTIONS_GHC -Wno-missing-export-lists #-}

-- | Copyright : (c) Crown Copyright GCHQ
module Bootstrap.Data.Config.Internal where

import Bootstrap.Data.Bootstrappable
  ( Bootstrappable
      ( bootstrapContent,
        bootstrapName,
        bootstrapReason
      ),
  )
import Bootstrap.Data.Bootstrappable.BootstrapState
  ( BootstrapState
      ( stateContinuousIntegrationConfig,
        stateDevContainerConfig,
        statePreCommitHooksConfig,
        stateProjectName,
        stateProjectType,
        stateUseFlakes
      ),
    bootstrapStateCodec,
  )
import Bootstrap.Data.ContinuousIntegration
  ( ContinuousIntegrationConfig,
  )
import Bootstrap.Data.DevContainer (DevContainerConfig)
import Bootstrap.Data.PreCommitHook (PreCommitHooksConfig)
import Bootstrap.Data.ProjectName (ProjectName)
import Bootstrap.Data.ProjectType
  ( ElmMode,
    ElmOptions,
    HaskellOptions,
    HaskellProjectType,
    JavaOptions,
    NodePackageManager,
    ProjectType,
    ProjectTypeV2,
    ProjectTypeV3,
    ProjectTypeV4,
    ProjectTypeV5,
    ProjectTypeV6,
    migrateProjectTypeFromV2,
    migrateProjectTypeFromV3,
    migrateProjectTypeFromV4,
    migrateProjectTypeFromV5,
    migrateProjectTypeFromV6,
  )
import Bootstrap.Monad (MonadBootstrap)
import Control.Lens (Iso', iso, makeLenses)
import Control.Monad.Catch (MonadThrow (throwM), catchAll, handleAll)
import Data.Singletons
  ( Sing,
    SingI (sing),
    SingKind (Demote, fromSing, toSing),
    SomeSing (SomeSing),
  )
import Dhall
  ( Decoder (Decoder, expected, extract),
    Encoder (Encoder, declared, embed),
    FromDhall (autoWith),
    InputNormalizer,
    ToDhall (injectWith),
    auto,
    inject,
    input,
  )
import Dhall.Core (Expr, pretty)
import qualified Dhall.Core as DCore
import Dhall.Deriving
  ( CamelCase,
    Codec (Codec),
    DropPrefix,
    Field,
    type (<<<),
  )
import Dhall.Src (Src)
import System.Directory (doesFileExist)
import System.Terminal (MonadPrinter (putTextLn))
import qualified Toml as TOML

-- | The version of `Config` being used
data ConfigVersion
  = V1
  | V2
  | V3
  | V4
  | V5
  | V6
  | V7

-- | Singled `ConfigVersion`
data SConfigVersion (configVersion :: ConfigVersion) where
  SV1 :: SConfigVersion 'V1
  SV2 :: SConfigVersion 'V2
  SV3 :: SConfigVersion 'V3
  SV4 :: SConfigVersion 'V4
  SV5 :: SConfigVersion 'V5
  SV6 :: SConfigVersion 'V6
  SV7 :: SConfigVersion 'V7

type instance Sing = SConfigVersion

instance SingKind ConfigVersion where
  type Demote ConfigVersion = ConfigVersion
  fromSing = \case
    SV1 -> V1
    SV2 -> V2
    SV3 -> V3
    SV4 -> V4
    SV5 -> V5
    SV6 -> V6
    SV7 -> V7
  toSing = \case
    V1 -> SomeSing SV1
    V2 -> SomeSing SV2
    V3 -> SomeSing SV3
    V4 -> SomeSing SV4
    V5 -> SomeSing SV5
    V6 -> SomeSing SV6
    V7 -> SomeSing SV7

-- | The most recent version of the config
type Current = 'V7

instance SingI Current where
  sing = SV7

-- | nix-bootstrap's configuration
type Config = VersionedConfig Current

-- | Config parameterised by `ConfigVersion`
data VersionedConfig version where
  VersionedConfigV1 :: BootstrapState -> VersionedConfig 'V1
  VersionedConfigV2 :: ConfigV2 -> VersionedConfig 'V2
  VersionedConfigV3 :: ConfigV3Plus 'V3 -> VersionedConfig 'V3
  VersionedConfigV4 :: ConfigV3Plus 'V4 -> VersionedConfig 'V4
  VersionedConfigV5 :: ConfigV3Plus 'V5 -> VersionedConfig 'V5
  VersionedConfigV6 :: ConfigV3Plus 'V6 -> VersionedConfig 'V6
  VersionedConfigV7 :: ConfigV3Plus 'V7 -> VersionedConfig 'V7

deriving stock instance Eq (VersionedProjectType version) => Eq (VersionedConfig version)

deriving stock instance Show (VersionedProjectType version) => Show (VersionedConfig version)

instance Bootstrappable Config where
  bootstrapName = const configPath
  bootstrapReason = const "This holds nix-bootstrap's configuration to ensure upgrades are reliable."
  bootstrapContent = pure . Right . (<> "\n") . (introComment <>) . pretty . extractUnions . embed inject
    where
      introComment :: Text
      introComment =
        unlines
          [ "-- This file was generated by nix-bootstrap.",
            "-- It should be checked into version control.",
            "-- It is used to aid migration between nix-bootstrap versions and preserve idempotence.",
            ""
          ]
      extractUnions :: Expr Src Void -> Expr Src Void
      extractUnions e =
        DCore.Let (DCore.makeBinding "NodePackageManager" . declared $ inject @NodePackageManager)
          . DCore.Let
            ( DCore.makeBinding "ElmMode"
                . runIdentity
                . DCore.subExpressions replaceFullTypes
                . declared
                $ inject @ElmMode
            )
          . DCore.Let
            ( DCore.makeBinding "ElmOptions"
                . runIdentity
                . DCore.subExpressions replaceFullTypes
                . declared
                $ inject @ElmOptions
            )
          . DCore.Let
            ( DCore.makeBinding "HaskellProjectType"
                . runIdentity
                . DCore.subExpressions replaceFullTypes
                . declared
                $ inject @HaskellProjectType
            )
          . DCore.Let
            ( DCore.makeBinding "HaskellOptions"
                . runIdentity
                . DCore.subExpressions replaceFullTypes
                . declared
                $ inject @HaskellOptions
            )
          . DCore.Let (DCore.makeBinding "JavaOptions" . declared $ inject @JavaOptions)
          . DCore.Let
            ( DCore.makeBinding "ProjectType"
                . runIdentity
                . DCore.subExpressions replaceFullTypes
                . declared
                $ inject @ProjectType
            )
          . runIdentity
          $ DCore.subExpressions replaceFullTypes e
      replaceFullTypes :: Expr Src Void -> Identity (Expr Src Void)
      replaceFullTypes =
        \case
          e@(DCore.Record _)
            | e == declared (inject @ElmOptions) -> Identity $ DCore.Var "ElmOptions"
            | e == declared (inject @HaskellOptions) -> Identity $ DCore.Var "HaskellOptions"
            | e == declared (inject @JavaOptions) -> Identity $ DCore.Var "JavaOptions"
            | otherwise -> DCore.subExpressions replaceFullTypes e
          e@(DCore.Field u@(DCore.Union _) fieldSelection)
            | u == declared (inject @ProjectType) ->
              Identity $ DCore.Field (DCore.Var "ProjectType") fieldSelection
            | otherwise -> DCore.subExpressions replaceFullTypes e
          e@(DCore.Union _)
            | e == declared (inject @ElmMode) -> Identity $ DCore.Var "ElmMode"
            | e == declared (inject @HaskellProjectType) -> Identity $ DCore.Var "HaskellProjectType"
            | e == declared (inject @NodePackageManager) -> Identity $ DCore.Var "NodePackageManager"
          e -> DCore.subExpressions replaceFullTypes e

instance ToDhall Config where
  injectWith inputNormaliser =
    let innerEncoder = injectWith inputNormaliser
     in Encoder
          { embed = \(VersionedConfigV7 c) -> embed innerEncoder c,
            declared = declared innerEncoder
          }

data VersionedProjectType (version :: ConfigVersion) where
  VPT3 :: ProjectTypeV3 -> VersionedProjectType 'V3
  VPT4 :: ProjectTypeV4 -> VersionedProjectType 'V4
  VPT5 :: ProjectTypeV5 -> VersionedProjectType 'V5
  VPT6 :: ProjectTypeV6 -> VersionedProjectType 'V6
  VPT7 :: ProjectType -> VersionedProjectType 'V7

instance FromDhall (VersionedProjectType 'V3) where
  autoWith = versionedProjectTypeFromDhall (Proxy @ProjectTypeV3) VPT3

instance FromDhall (VersionedProjectType 'V4) where
  autoWith = versionedProjectTypeFromDhall (Proxy @ProjectTypeV4) VPT4

instance FromDhall (VersionedProjectType 'V5) where
  autoWith = versionedProjectTypeFromDhall (Proxy @ProjectTypeV5) VPT5

instance FromDhall (VersionedProjectType 'V6) where
  autoWith = versionedProjectTypeFromDhall (Proxy @ProjectTypeV6) VPT6

instance FromDhall (VersionedProjectType 'V7) where
  autoWith = versionedProjectTypeFromDhall (Proxy @ProjectType) VPT7

instance ToDhall (VersionedProjectType 'V3) where
  injectWith = versionedProjectTypeToDhall (Proxy @ProjectTypeV3) (\(VPT3 x) -> x)

instance ToDhall (VersionedProjectType 'V4) where
  injectWith = versionedProjectTypeToDhall (Proxy @ProjectTypeV4) (\(VPT4 x) -> x)

instance ToDhall (VersionedProjectType 'V5) where
  injectWith = versionedProjectTypeToDhall (Proxy @ProjectTypeV5) (\(VPT5 x) -> x)

instance ToDhall (VersionedProjectType 'V6) where
  injectWith = versionedProjectTypeToDhall (Proxy @ProjectTypeV6) (\(VPT6 x) -> x)

instance ToDhall (VersionedProjectType 'V7) where
  injectWith = versionedProjectTypeToDhall (Proxy @ProjectType) (\(VPT7 x) -> x)

versionedProjectTypeFromDhall ::
  forall underlying version.
  FromDhall underlying =>
  Proxy underlying ->
  (underlying -> VersionedProjectType version) ->
  InputNormalizer ->
  Decoder (VersionedProjectType version)
versionedProjectTypeFromDhall Proxy constructor normaliser =
  Decoder {extract = constructor <<$>> extract, ..}
  where
    Decoder {..} = autoWith @underlying normaliser

versionedProjectTypeToDhall ::
  forall underlying version.
  ToDhall underlying =>
  Proxy underlying ->
  (VersionedProjectType version -> underlying) ->
  InputNormalizer ->
  Encoder (VersionedProjectType version)
versionedProjectTypeToDhall Proxy unwrap normaliser =
  Encoder {embed = embed . unwrap, ..}
  where
    Encoder {..} = injectWith @underlying normaliser

_VersionedProjectType :: Iso' (VersionedProjectType Current) ProjectType
_VersionedProjectType = iso (\(VPT7 x) -> x) VPT7

-- | The location of a bootstrapped config file
configPath :: FilePath
configPath = ".nix-bootstrap.dhall"

-- | Errors which occur during TOML decoding
newtype TomlDecodeException = TomlDecodeException {unTomlDecodeException :: [TOML.TomlDecodeError]}
  deriving stock (Show)

instance Exception TomlDecodeException where
  displayException = toString . TOML.prettyTomlDecodeErrors . unTomlDecodeException

-- | Parses the given text as a nix-bootstrap config file
parseVersionedConfig ::
  forall m version.
  MonadBootstrap m =>
  SConfigVersion version ->
  Text ->
  m (Either SomeException (VersionedConfig version))
parseVersionedConfig v s = case v of
  SV1 ->
    pure
      . bimap (SomeException . TomlDecodeException) VersionedConfigV1
      $ TOML.decode bootstrapStateCodec s
  SV2 -> parseFor VersionedConfigV2
  SV3 -> parseFor VersionedConfigV3
  SV4 -> parseFor VersionedConfigV4
  SV5 -> parseFor VersionedConfigV5
  SV6 -> parseFor VersionedConfigV6
  SV7 -> parseFor VersionedConfigV7
  where
    parseFor :: FromDhall config => (config -> versionedConfig) -> m (Either SomeException versionedConfig)
    parseFor constructor = handleAll (pure . Left) . fmap (Right . constructor) . liftIO $ input auto s

-- | The second version of the config
data ConfigV2 = ConfigV2
  { _configV2ProjectName :: ProjectName,
    _configV2ProjectType :: ProjectTypeV2,
    _configV2SetUpPreCommitHooks :: PreCommitHooksConfig,
    _configV2SetUpContinuousIntegration :: ContinuousIntegrationConfig,
    _configV2SetUpVSCodeDevContainer :: DevContainerConfig,
    _configV2UseNixFlakes :: Bool
  }
  deriving stock (Eq, Generic, Show)
  deriving (FromDhall, ToDhall) via Codec (Field (CamelCase <<< DropPrefix "_configV2")) ConfigV2

-- | The third version of the config
data ConfigV3Plus (version :: ConfigVersion) = ConfigV3Plus
  { _configV3ProjectName :: ProjectName,
    _configV3ProjectType :: VersionedProjectType version,
    _configV3SetUpPreCommitHooks :: PreCommitHooksConfig,
    _configV3SetUpContinuousIntegration :: ContinuousIntegrationConfig,
    _configV3SetUpVSCodeDevContainer :: DevContainerConfig,
    _configV3UseNixFlakes :: Bool
  }
  deriving stock (Generic)

deriving stock instance Eq (VersionedProjectType version) => Eq (ConfigV3Plus version)

deriving stock instance Show (VersionedProjectType version) => Show (ConfigV3Plus version)

deriving via
  (Codec (Field (CamelCase <<< DropPrefix "_configV3")) (ConfigV3Plus version))
  instance
    FromDhall (VersionedProjectType version) => FromDhall (ConfigV3Plus version)

deriving via
  (Codec (Field (CamelCase <<< DropPrefix "_configV3")) (ConfigV3Plus version))
  instance
    ToDhall (VersionedProjectType version) => ToDhall (ConfigV3Plus version)

-- | The outcome of trying to load the `Config`
data LoadConfigResult
  = -- | The config is up-to-date, or has been migrated from a previous version
    -- to the current version
    LoadConfigResultFound Config
  | -- | The config is invalid, and doesn't match any config version
    LoadConfigResultError SomeException
  | -- | There is no existing config
    LoadConfigResultNotFound

deriving stock instance Show Config => Show LoadConfigResult

makeLenses ''ConfigV3Plus

-- | Isomorphism to the current config version
_Current :: Iso' Config (ConfigV3Plus Current)
_Current = iso (\(VersionedConfigV7 c) -> c) VersionedConfigV7

-- | Loads the config from the appropriate file
loadConfig :: MonadBootstrap m => m LoadConfigResult
loadConfig = loadConfig' @Current sing

-- | Tries to load the specified config version, then tries previous versions
-- until one is found to succeed (or none are).
loadConfig' :: forall version m. MonadBootstrap m => SConfigVersion version -> m LoadConfigResult
loadConfig' nextToTry = do
  ((Right <$> loadConfigAtVersion nextToTry) `catchAll` (pure . Left)) >>= \case
    Right Nothing -> pure LoadConfigResultNotFound
    Right (Just c) -> pure $ LoadConfigResultFound c
    Left e -> tryPreviousConfigVersion e nextToTry
  where
    tryPreviousConfigVersion :: SomeException -> SConfigVersion v -> m LoadConfigResult
    tryPreviousConfigVersion e v = case v of
      SV7 -> loadConfig' SV6
      SV6 -> loadConfig' SV5
      SV5 -> loadConfig' SV4
      SV4 -> loadConfig' SV3
      SV3 -> loadConfig' SV2
      SV2 -> loadConfig' SV1
      SV1 -> pure $ LoadConfigResultError e

-- | Loads and parses the config at the specified version.
--
-- ### Throws
--
-- * `IOException` if the file can't be loaded
-- * `SomeException` if the config can't be loaded or parsed.
loadConfigAtVersion :: MonadBootstrap m => SConfigVersion version -> m (Maybe Config)
loadConfigAtVersion v = do
  let path = case v of SV1 -> ".nix-bootstrap.toml"; _ -> configPath
  liftIO ((,) <$> doesFileExist ".nix-bootstrap.toml" <*> doesFileExist configPath) >>= \case
    (False, False) -> pure Nothing
    _ -> do
      fileContents <- decodeUtf8With lenientDecode <$> readFileBS path
      either throwM (pure . pure . upgradeConfig v) =<< showPath path =<< parseVersionedConfig v fileContents
  where
    showPath ::
      MonadBootstrap m =>
      FilePath ->
      Either SomeException (VersionedConfig version) ->
      m (Either SomeException (VersionedConfig version))
    showPath path c = c <$ putTextLn ("Loaded config from " <> toText path)

-- | Migrates an outdated config version to the current version
upgradeConfig :: SConfigVersion version -> VersionedConfig version -> Config
upgradeConfig _ = \case
  VersionedConfigV1 s ->
    VersionedConfigV7
      ConfigV3Plus
        { _configV3ProjectName = stateProjectName s,
          _configV3ProjectType = VPT7 . migrateProjectTypeFromV2 $ stateProjectType s,
          _configV3SetUpPreCommitHooks = statePreCommitHooksConfig s,
          _configV3SetUpContinuousIntegration = stateContinuousIntegrationConfig s,
          _configV3SetUpVSCodeDevContainer = stateDevContainerConfig s,
          _configV3UseNixFlakes = stateUseFlakes s
        }
  VersionedConfigV2 ConfigV2 {..} ->
    VersionedConfigV7
      ConfigV3Plus
        { _configV3ProjectName = _configV2ProjectName,
          _configV3ProjectType = VPT7 $ migrateProjectTypeFromV2 _configV2ProjectType,
          _configV3SetUpPreCommitHooks = _configV2SetUpPreCommitHooks,
          _configV3SetUpContinuousIntegration = _configV2SetUpContinuousIntegration,
          _configV3SetUpVSCodeDevContainer = _configV2SetUpVSCodeDevContainer,
          _configV3UseNixFlakes = _configV2UseNixFlakes
        }
  (VersionedConfigV3 c) -> migrateFromV3Plus c (\(VPT3 x) -> x) migrateProjectTypeFromV3
  (VersionedConfigV4 c) -> migrateFromV3Plus c (\(VPT4 x) -> x) migrateProjectTypeFromV4
  (VersionedConfigV5 c) -> migrateFromV3Plus c (\(VPT5 x) -> x) migrateProjectTypeFromV5
  (VersionedConfigV6 c) -> migrateFromV3Plus c (\(VPT6 x) -> x) migrateProjectTypeFromV6
  c@(VersionedConfigV7 _) -> c
  where
    migrateFromV3Plus ConfigV3Plus {..} deconstruct migrate =
      let oldProjectType = deconstruct _configV3ProjectType
       in VersionedConfigV7
            (ConfigV3Plus {_configV3ProjectType = VPT7 $ migrate oldProjectType, ..})
